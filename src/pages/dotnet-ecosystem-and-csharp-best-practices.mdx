import { Lecture, Message, TimelineOfContents, Level } from "../components";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faFacebookSquare, faGithub, faLinkedin, faSkype } from "@fortawesome/free-brands-svg-icons";
import rostyslavDiakivAvatar from "../assets/avatars/rostyslav-diakiv-2019.svg";

<div><h1><strong>.NET ecosystem and C# best practices</strong></h1></div>

<div>
  <div class="author">
    <div id="avatar-wrapper">
      <object id="avatar" data={rostyslavDiakivAvatar} role="img" aria-label="My profile picture"></object>
    </div>
    <div class="profile">
      <h3 class="name">Ростислав Дяків</h3>
      <ul class="contacts">
        <li>
          <a href="https://www.facebook.com/rostislav.dyakiv" rel="author" class="facebook">
            <FontAwesomeIcon icon={faFacebookSquare} className="icon" />
            <span>rostislav.dyakiv</span>
          </a>
        </li>
        <li>
          <a href="https://github.com/rostyslav-diakiv" rel="author" class="github">
            <FontAwesomeIcon icon={faGithub} className="icon" />
            <span>rostyslav-diakiv</span>
          </a>
        </li>
        <li>
          <a href="https://www.linkedin.com/in/rostyslav-diakiv/" rel="author" class="linkedin">
            <FontAwesomeIcon icon={faLinkedin} className="icon" />
            <span>rostyslav-diakiv</span>
          </a>
        </li>
        <li>
          <a href="skype:rostik8803" rel="author" class="skype">
            <FontAwesomeIcon icon={faSkype} className="icon" />
            <span>rostik8803</span>
          </a>
        </li>
      </ul>
      <p class="about">
        Володя працює фулл-стек розробником у <a href="https://binary-studio.com"><strong>Binary Studio</strong></a> вже 2 роки, де будує точні, адаптивні, швидкі, зручні в користуванні середовища, які гарно виглядають та добре виконують свої завдання. Улюбленими технологіями вважає <a href="#"><strong>React</strong></a> та <a href="#"><strong>GraphQL</strong></a>. Говорить російською із смішним акцентом.
      </p>
    </div>
  </div>
  <div class="bubble" style="margin: -0.5em 1em 1em;">
    <strong>Hey, hola, привіт!</strong><br />Вже за два абзаци розпочнеться лекція. Але! Спочатку пара коротеньких дісклеймерів: 1) деякі терміни та технології не пояснюються, лінки на документацію та ґайдлайни опціональні <em>(їх можна повністю проігнорувати, маючи сильну інтуїцію, багаж знань чи достатньо часу на експерименти)</em>; 2) лекція намагається бути фановою і максимально корисною, але не завжди так буде виходити в результаті &#x1F937;&#x200D;&#x2642;&#xFE0F; <em>(за бекання-мекання і вживання іншомовних слів пробачте, будь ласка)</em>. Між іншим, it's dangerous to go alone! Take this: <a href="https://git-scm.com/"><strong>Git</strong></a>, <a href="https://desktop.github.com/"><strong>GitHub Desktop</strong></a>, <a href="https://code.visualstudio.com/"><strong>Visual Studio Code</strong></a>
  </div>
</div>

<div id="table-of-contents" class="table-of-contents">
  <TimelineOfContents timeline={[{
    linkTo: "#dotnet-platform-overview",
    title: "Огляд .NET платформи"
  }, {
    linkTo: "#dotnet-under-the-hood",
    title: ".NET під катопом"
  }, {
    linkTo: "#",
    title: "Основи C#"
  }, {
    linkTo: "#clean-code-principles",
    title: "Принципи чистого коду"
  }]} />
</div>

<Level id="dotnet-platform-overview" number="1" name="Огляд .NET платформи" difficulty="Мамкин комп'юторщик." objectives="Зрозуміти SDK." labels={{ level: "Розділ", backToTop: "нагору", difficulty: "Складність:", objectives: "Мета:" }} />

<ul>
  <li class="details">
    <input type="checkbox" id="accordion-1-1" />
    <label class="summary" for="accordion-1-1">
      <h5><strong>.NET platform</strong></h5>
    </label>
    <div class="details-body">
      <p>Зараз інфраструктура .NET-y виглядає наступним чином:</p>
      <div class="columns text-center">
        <div class="column col-4">
          <div class="panel">
            <div class="panel-header">
              <strong>.NET framework</strong>
            </div>
            <div class="panel-body">
              <div class="columns">
                <div class="column col-2">WPF</div>
                <div class="column col-7">Windows Forms</div>
                <div class="column col-3">ASP.NET</div>
              </div>
            </div>
          </div>
        </div>
        <div class="column col-4">
          <div class="panel">
            <div class="panel-header">
              <strong>.NET Core</strong>
            </div>
            <div class="panel-body">
              <div class="columns">
                <div class="column col-6">UWP</div>
                <div class="column col-6">ASP.NET Core</div>
              </div>
            </div>
          </div>
        </div>
        <div class="column col-4">
          <div class="panel">
            <div class="panel-header">
              <strong>Xamarin</strong>
            </div>
            <div class="panel-body">
              <div class="columns">
                <div class="column col-4">iOS</div>
                <div class="column col-4">MacOS</div>
                <div class="column col-4">Android</div>
              </div>
            </div>
          </div>
        </div>
        <div class="column col-12">
          <div class="panel">
            <div class="panel-header">
              <strong>.NET Standard Library</strong>
            </div>
          </div>
        </div>
        <div class="column col-12">
          <div class="panel">
            <div class="panel-header">
              <strong>Common infrastructure</strong>
            </div>
            <div class="panel-body">
              <div class="columns">
                <div class="column col-4">Compilers</div>
                <div class="column col-4">Languages</div>
                <div class="column col-4">Runtime components</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <p>Є 3 шляхи створення .NET-додатків:</p>
      <ol>
        <li>1. Це використовувати старий добрий `.Net Framework`, запускати його на віндовс і радіти життю</li>
        <li>2. Це писати крос-платформні веб додатки за допомогою web-framework-y `ASP.NET Core`. Або ж гібридні додатки з `UWP- Universal Windows Platform`, що дозволяє запускати програму написану на цій технології на `Windows` машині, `X-Box`-i, `Hololens`-i та ще якісь біді від Майкрософт</li>
        <li>3. І третій спосіб - Xamarin. Платформа для створення мобільних додатків для IOS i Android, використовуючи `C#` та `.Net`</li>
      </ol>
      <p>Код який написаний під спеціальний фреймворк, як `WPF`, `Asp.Net Core` чи `Android` не можна перевикористати на іншій платформі із зрозумілих сподіваюсь причин, так як він заточений для роботи з так званими `Platform-specific API` який відрізняється у них всіх.</p>
      <p>Для вирішення цієї проблеми, а саме перевикористання коду бізнес-логіки, хелпер методів, меделей, класів і так далі у іншій платформі створили `.Net Standart` - який надає набір доступних `АPI`, що працює на усіх платформах:</p>
      <ul>
        <li>настільних програмах</li>
        <li>веб-додатках</li>
        <li>мобільних додатках і іграх</li>
        <li>хмарних службах</li>
      </ul>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-1-2" />
    <label class="summary" for="accordion-1-2">
      <h5><strong>NuGet</strong></h5>
    </label>
    <div class="details-body">
      <p>Ключовий інструмент для будь-якої сучасної платформи розробки - це механізм, за допомогою якого розробники можуть створювати, передавати один одному і використовувати корисний код. Часто такий код розподілений по "`пакетах`", що включає скомпільований код (у вигляді бібліотек `DLL`). Для `.NET`-у механізмом спільного використання коду, підтримуваним `Майкрософт`, є `NuGet`. За допомогою `NuGet` ви можете скачувати пакети з кодом із центрального репозиторія `NuGet Gallery`, який уже налічує близько `100_000` унікальних пакетів. Також якщо ви написали якусь круту бібліотеку для роботи з чимось - наприклад з файловою системою - whatever. Ви з легкістю можете самі створити `NuGet пакет` та запаблішити його, щоб інші розробники могли використовувати вашу працю. Простіше кажучи, пакет `NuGet` є окремим `ZIP-файл` з розширенням .nupkg, який містить скомпільований код -`DLL`, інші файли, пов'язані з цим кодом та маніфест.</p>
    </div>
  </li>
</ul>

<Level id="dotnet-under-the-hood" number="2" name=".NET під капотом" difficulty="Мамкин комп'юторщик." objectives="Зрозуміти SDK." labels={{ level: "Розділ", backToTop: "нагору", difficulty: "Складність:", objectives: "Мета:" }} />

#### **CLR**

Сьогодні у `.Net` світі 3 найпоширеніші мови програмування це `C#`, `F#` та `Visual Basic .Net`.

У кожної є свій компілятор, який перетворює код написаний на цій мові у `IL - Intermediate Language Code`,
який представляє з себе набір інструкцій для віртуальної машини `.Net` - `CLR - Common Language Runtime`.

Основні етапи виконання програми `.Net`:

1. Спочатку написаний нами код, компілятор `C#` перетворить `C#` code на `IL`.
2. Тоді, коли прийде час для виконання частини нашого коду в програмі - `CLR` за допомогою `JIT - Just in Time компілятора ` перетворить код `IL` на `машинний код`.

Важливо зазначити, що перетворення `IL` в `машинний код` відбувається лише тоді коли потрібно, тобто буде перетворена тільки та частина коду, яка має виконатись в теперішній момент часу.

Результатом білда `.Net` програми є файл з розширенням `.exe` - executable файл, або: `dll` - `Dynamic Link Library`

#### **C# → IL Code**
`C# компілятор` перетворить код написаний вище у проміжну мову, яка виглядатиме так: 

На цьому слайді можна побачити у який `IL Code` перетвориться функція, написана на `C#` 

#### **Value and Reference types**

На найвищому рівні у `С#` є 2 типи даних - це значимі типи(`value types`) і ссилочні типи (`reference types`).

Важливо розуміти відмінності між ними.

До значимих типів у `.Net` відносяться: 

* `Целочисленні типи`
* `Типи з плаваючою крапкою`
* `decimal`
* `bool`
* `enum`-и
* `структури`

До `Ссилочних`:

* тип `object`
* `string`
* `класи`
* `інтерфейси`
*  та `делегати`

Різниця між ними у тому, де вони зберігаються у пам'яті та як передаються у метод.

#### **Stack and Heap**

У `.NET`-і пам'ять ділиться на два типи: на `стек` і `кучу`

`Стек` являє собою структуру даних, яка росте знизу вгору: кожен новий елемент, поміщається поверх попереднього.

У стеку зберігаються `Значимі типи` та посилання на `Ссилочні типи`, що у свою чергу розміщуться на `кучі`

`Кучу` можна уявити як невпорядкований набір різнорідних об'єктів.

При створенні об'єкту `Ссилочного типу` в `стек` додається посилання на адресу цього об'єкту на `кучі`.
 
Коли об'єкт `Ссилочного типу` перестає використовуватися, то посилання з стеку видаляється, і пам'ять очищається.

Після цього у справу вступає автоматичний зборщик мусору - `Garbage Collector`: він бачить, що на об'єкт в кучі більше немає посилань, видаляє цей об'єкт та очищує пам'ять.

#### **ref, out parameters**

Важливий момент у тому, як змінні `Значимих` та `Ссилочних` типів передаються у метод.

1. На першому прикладі показано як цілочисельна змінна `c` - 20 передається до методу, змінюється на 1, але на після виконання методу залишається з початковим значенням.

2. У другому прикладі показано як цілочисельна змінна `d` - 30 передається до методу за посиланням, змінюється на 2, і після виконання методу її значення буде дорівнювати 2-ом, через те що ми її передали у метод, використавши оператор `ref`, який дозволяє нам передавати значимі типи за посиланням.

3. У третьому прикладі показано як цілочисельна змінна - `e` передається до методу за посиланням, де ініціалізується значенням 3, і після виконання методу її значення буде дорівнювати 3-ом, через те що ми її передали у метод, використавши оператор `out`. Відмінність між `ref` і `out` у тому, що `ref` вимагає що змінна має бути попередньо ініціалізована і те що при `out` ми зобов'язані призвоїти значення змінній.

4. У останньому прикладі показано як створюється екземпляр класу `City` із публічним членом `code` з першочерговим значенням - 12. Далі посилання на об'єкт на кучі city передається у метод, де його поле `code` змінюється на 0. Після виконання методу ми бачимо очікуваний результат, що поле об'єкту ссилочного типу змінилось на нуль.  

#### **Boxing - Unboxing**

Операція упаковки - `boxing`-гу характеризується виділенням пам'яті на кучі під об'єкт значимого типу - value type і присвоєння ссилки на цю ділянку пам'яті змінної в стеці.

Розпакування `unboxing`, навпаки, виділяє пам'ять в стеку під об'єкт, отриманий з кучі по ссилці.

#### **Class vs Struct**

`Kлас` проти `Cтруктури`. **Структури** по вигляу дуже схожі на **Класи**, але існує принципова відмінність, яка згадувалась раніше. Клас - це *reference type** і передається по ссилці, а структура - **value type** і передається за значенням - тобто копіюється.

Структури краще використовувати для невеликих класів, маленьких структур даних та легковєсних об'єктів

Щодо класів, то можна сказати що у всіх випадках де вам незручно використовувати структуру - використовуйте класи та не ускладнюйте собі життя.
Класи чудово підходять для того щоб бути частиною ієрархії сутностей, мати внутрішнім стан та містити в собі велику кількість бізнес логіки.  

#### **Static members**

Клас може мати статичні поля, методи та властивості. Якщо член класу статичний, то він відносяться до всього класу і для звернення до нього не треба створювати екземпляр класу.

На прикладі показано що статичне поле є спільним для усіх об'єктів класу і може використовуватись і нестатичний методах. У той час як у статичних методах у нас немає доступу до нестатичних членів класу. 

#### **Params**

Використовуючи ключове слово params, ви можете вказати параметр методу, що він приймає довільну кількість аргументів - нуль або більше.

Далі ці аргументи в тілі методі можна використовувати в контексті масиву.

Передавати аргументи у метод в якого змінна кількість параметрів можна просто перераховуючи їх через кому як показано на слайді.

Варто зазначити, що аргумент `params` повинен бути останнім і йти після усіх строго визначених аргументів методу.

#### **Nullable**

Явно структурному типу даних ми не можемо присвоїти `null`. Щоб це зробити, на потрібно оголосити змінну з модифікатором `?`. Цей модифікатором являється алаясом до структури `Nullable<T>`, що є так званою обгорткою для структур, що і показано на сигнатурі.

Обгортаючи змінну в `Nullable` тип у нас з'являється новий `АРІ` для взаємодії з цією змінною.

* А саме властивіть `HasValue`, що повертає `true`, якщо змінна містить значення, або `false`, якщо вона `null`
* Та `Value` повертає реальне значення яке зберігається у змінній, якщо `HasValue` дорівнює `true`. Інакше, викидає InvalidOperationException, якщо змінна `null`.

#### **Interface vs Abstract Class**

А ми рухаємось далі і переходимо до... `абстрактних класів` та  `інтерфейсів`

У C# `абстракція` використовується для приховання деталей реалізації. 

Це означає, що ми зосерджуємось на тому, що об'єкт може робити, а не на тому, як він це робить. Це особливо використовується для великих і складних програм. 

Щоб цього досягти використовуються `абстрактні класи` та  `інтерфейси`.

У `абстрактном класі` ми можемо створити функціональність, яка має бути реалізована у похідному класі. 

З свого боку `інтерфейс` дозволяє визначити функціональні можливості або функції, але не може їх реалізувати. 

Клас імплеменує інтерфейс та обов'язково реалізує ці методи, якщо він не є `абстрактним`.

Розглянемо кілька ключових відмінностей між ними...

#### **#1**

`Інтерфейс` не може мати модифікаторів доступу до членів - все що є в `інтерфейсі` по дефолтну є публічним.

У абстрактного класу все залишається як і звичайного класу
-----------------------

#### **#2**

Ми не можемо явно створити інстанс `Інтерфейсу` чи `абстрактного класу` викликавши конструкор.

Хоча нагадаю що у `абстрактного класу` він може бути.

Він здебільшого використовується для виклику у конструкторі `похідного класу`, щоб не дублювати код ініціалізації полів чи властивостей `абстрактного класу`.

В `Інтерфейсі` ми можемо лише описати сигнатуру методу без його імплементації

У `Абстрактному класі` ми можемо повністю імплементувати метод який нас цікавить. Для цього у метод має бути не абстрактним.
-----------------------

#### **#3**

Ми не можемо оголосити конструктор у тілі інтерфейсу, ні з модифікатором доступу ні без нього.

У Абстрактному класі ми можемо оголошувати конструктори з тими самими правилами, що і у звичайних класах
-----------------------

#### **#4**

Ми не можемо явно створити інстанс `ітерфейсу` чи `абстрактного класу` викликавши конструкор.

Хоча нагадаю що у `абстрактного класу` він може бути.

Він здебільшого використовується для виклику у конструкторі `похідного класу`, щоб не дублювати код ініціалізації полів чи властивостей `абстрактного класу`.
-----------------------

#### **#5**

`Інтерфейс` не може мати модифікаторів доступу до членів - все що є в `інтерфейсі` по дефолтну є публічним.

У `абстрактного класу` все залишається як і звичайного класу
-----------------------

#### **#6**

Абсолютно всі члени `інтерфейсу` є абстрактними, тобто не мають реалізації.

А щодo `абстрактного класу`, то в ньому можуть бути як абстрактні методи та властивості так і не абстрактні - з повною, або частковою реалізацією.
-----------------------

#### **Interface vs Abstract Class - Conclusion **

Отже, коли ми дізналися про головні характеристики `абстрактного класу` та  `інтерфейсу`, назріває питання - 'що і коли вибрати?'.

Інтерфейс краще підходить у випадках, коли потрібно, щоб кілька класів імплементували інтерфейс.

Члени інтерфейсу не можуть бути статичними. Абстрактний клас надає можливість зберігати стан класу в цілому, а не окремого об'єкту.

C# не підтримує множинне наслідування, як С++, а інтерфейси в основному використовуються щоб це зробити. Так як клас може реалізовувати більше одного інтерфейсу і наслідуватись лише від одного абстрактного класу. 

Абстрактний клас використовується якщо ми хочемо його включити в ієрархію успадкувань. І створити функціонал з повною або частковою реалізацією, яку клас наслідник може імплементувати або перевизначити. 

Інтерфейс в основному використовується тільки тоді, коли ми хочемо просто описати `API` використання класів які будуть імплементувати цей інтерфейс.

Таких класів гіпотетично може бути декілька і швидше за все - це не єдиний інтерфейс який вони будуть імплементувати.

Це саме той випадок коли інтерфейс є чи не єдиним правильним рішенням  

#### **Extension methods **

`Extension` методи дозволяють "додавати" методи до існуючих типів без створення нового похідного типу, перекомпіляції або модифікації оригінального типу.

`Extension` метод це особливий статичним методом, який має обов'язково бути членом статичного класу.

На прикладі показано `Extension` метод для типу `String`. Статичний клас може мати довільну назву, в той час як назва методу має відрізнятись від уже існуючих методі у класі який ми розширюємо.

Надалі ми можемо використовувати оголошений нами метод як і звичайні методи класу який ми розширюємо. 

#### **Generics**

`Дженеріки`. Вони були додані до мови `C#` з другої версії.

`Дженеріки` привнесли в `.NET` концепт типізованих параметрів, що дозволяє проектувати класи та методи, які відкладають визначення типу одного, або більше членів класу чи методу, допоки вони не будуть ініціалізовані тим, хто їх використовує.

Наприклад: використовуючи загальний параметр типу `Т`, чи можемо написати єдиний клас, який може використовуватись клієнтським кодом без ризику здійснення операцій `boxing-y` які є самі по собі важкими операціями і зловживати ними не є добре.  

Як видно з наведеного вище коду, MyGenericClass визначений з `<T>`. `<>` вказує, що `MyGenericClass` є дженеріком, і тип `Т` буде визначено пізніше. Можете використовувати будь-які букви або слово замість `T`, це немає значення.

Тепер компілятор призначає тип членів класу на основі типу, переданого  програмістом при створенні класу. Наприклад, наступний код використовує тип даних `int`.

#### **Constraints in Generics**

У C# є `Constraint`-и, для того щоб обмежити які типи можна використовувати у дженерік класі. Наприклад, якщо `Constraint`-ом ми вказуємо що типом `Т` може бути тільки `reference type`, тобто `класи`, то не можна використати `value type`-и для створення екземпляру дженерік класу.

Тож тепер ми не можемо використовувати структурні типи даний як int - це викличе помилку компіляції

#### **All Constraints in Generics**

Тут зібрані усі можливі Constraint-и, якими можна обмежувати типи, для використання в дженерік класах.

#### **Tuples**

Якщо вам потрібно склеїти два значення, щоб повернути їх з функції або помістити два значення в хеш-набір, ви можете використовувати типи System.ValueTuple і створити їх за допомогою зручного синтаксису:

1. Приклад створення кортежу
2. Використання кортежу для типізування Dictionary
3. Додавання елементу кортеду в Dictionary
4. Дістаємо значення словника по ключу
5. Деструктуризація елементу кортежу
6. Доступ до членів кортежу по імені 
7. Приклад того як повертати з функції значення в кортежі

#### **Events & Delegates + Lambdas**

Тепер переходимо до Подій та Делегатів. 

Делегати це об'єкти, які вказують на методи. За допомогою них ми можемо викликати дані методи.

Тут зібрані усі можливі Constraint-и, якими можна обмежувати типи, для використання в дженерік класах.

#### **Program Example**

Спочатку ми оголошуємо сигнатуру делегату.

Це означає, що методи, на які може вказувати делегат мають мати такі ж самі параметри та повартаючий тип, що і делегат.

У нашому випадку делегат LogMessage має 1 параметр стрінг і повертає нічого.

В класі програм ми оголосили 2 методи LogRedMessage та LogGreenMessage з тою самою сигнатурою що і у делегата, тому ми можемо присвоїти йому посилання на ці методи.

Спочатку ми створюємо змінну делегату, присвоюючи йому адресу методу LogRedMessage і викликаємо його за допомогою методу делегата Invoke, передаючи у цей метод параметри - а саме 1-ну стрічку "Hello world!".

Далі ми додаємо посилання на ще 1 метод LogGreenMessage цьому делегату і  при наступному виконанню делегата, ми уже викличемо 2 методи які ми заасайнили цьому делегату і у консоль виведуться 2 стрічки "Second message" червоного та зеленого кольору. 

Викликати делегат можна і без Invoke, просто за допомогою круглих дужок, передавши аргументи.

#### **Action, Func і Predicate**

Замість визначення нового типу делегата, можна використовувати делегати Action, Func і Predicate. 

Дженерік делегат Action &lt;T&gt; призначений для ссилки на метод, що повертає void. Класу цього делегата можна передавати до 16 параметрів довільного типу.

--------------------------------

Делегати Func можуть використовуватися аналогічним чином. Func дозволяє викликати методи які щось повертають. Йому так само можна передавати до 16 типів параметрів і 1 тип який він повертає. 

--------------------------------

Делегат Predicate, як правило, використовується для порівняння деякого об'єкта T певній умові. Він повертає true, якщо об'єкт задовільняє умову, і false, якщо ні.
**Щоб підсумувати варто сказати, що суть делегатів у тому, що вони дозволяють представляти методи у вигляді об'єктів і передавати їх до функцій, використовувати як колбеки і так далі.**
#### **Events & Delegates Flow**

З делегатами розібралися, переходимо до подій... 

Події дозволяють сигналізують системі про те, що відбулося певна дія.

Існує така модель Видавець-Підписник.

Підписник підписується на подію, визначає обробник і чекає допоки Видавець викличе цю подію.

#### **Demo**

Звучить просто, подивимся як буде на практиці i переходимо до **Demo**.

Я підготував клас `Wallet` - гаманець. Говорити про поля і тд

Події оголошуються в класі з допомогою ключового слова event, після якого йде назва делегата.

Зв'язок з делегатом означає, що метод, який обробляє цю подію, має мати сигнатуру делегату.

#### **Collections - Hierarchy**

Хоча в мові C# є `масиви`, які зберігають в собі набори однотипних об'єктів, але працювати з ними не завжди зручно.

Так як масив зберігає фіксовану кількість об'єктів, а ми заздалегідь не знаємо, скільки у нас буде об'єктів, в цьому випадку набагато зручніше буде застосовувати колекції.

Визначну роль у виборі колекцій може зіграти те, що деякі з них реалізують стандартні структури даних, такі як:
* стек
* чергу
* словник
* і так далі

які можуть стати в нагоді для вирішення різних спеціальних завдань.

Основою для створення всіх колекцій є реалізація інтерфейсів `IEnumerator` і `IEnumerable`. 

Інтерфейс `IEnumerator` представляє `Перечислитель`, за допомогою якого стає можливий послідовний перебір колекції, наприклад, в циклі `foreach`.

А інтерфейс `IEnumerable` через свій метод `GetEnumerator` надає Перечислитель всім класам, які реалізують даний інтерфейс.

Тому інтерфейс `IEnumerable` є базовим для усіх колекцій.

#### **ArrayList & List**

На прикладі використовуються дві колекції: `non-generic` - `ArrayList` та `generic` - `List`.

Зараз хорошою практикою вважається використовувати дженерік версії коллекцій де це тільки можливо - через строгу типізацію та зручність у використанні.

Більшість колекцій підтримують додавання елементів.

Наприклад, в даному випадку додавання проводиться методом `Add`, але для інших колекцій назву методу може відрізнятися.

Також більшість колекцій реалізують видалення (в даному прикладі проводиться за допомогою методу `RemoveAt`).

За допомогою властивості `Count` у колекцій можна подивитися кількість елементів.

І так як колекції реалізують інтерфейс `IEnumerable`, то всі вони підтримують перебір в циклі `foreach`.

Конкретні методи і способи використання можуть відрізнятися від одного класу колекції до іншої, але загальні принципи будуть одні і ті ж для всіх класів колекцій.

#### **List is Array wrapper**

По суті такі колекції як `ArrayList`, `List`, `Stack`, `Queue` та інші це ніщо інше як зручні обгортки над `масивами` для роботи з набором даних.

Зараз я продемонструю створення власноЇ колекції на основі масиву та покажу як можна проходитись по ній в циклі ForEach.

Kолекцію буде називатись `CustomCollection`.

#### **Exceptions**

Іноді при виконанні програми виникають помилки, які важко або неможливо передбачити. 

Наприклад, при передачі файлу по мережі може обірватися підключення, інтернет пропаде, такі ситуації називаються Exception-ами.

Мова C# надає розробникам можливості для обробки таких ситуацій засобами конструкції try...catch...finally.

При використанні блоку try...catch...finally спочатку виконуються всі інструкції в блоці try.

Якщо в цьому блоці не виникло Exception-ів, то після нього  виконається блок finally і конструкція try..catch..finally завершить свою роботу.

Якщо ж в блоці try виникає Exception, то звичайний флов виконання зупиняється, і CLR починає шукати блок catch, який може обробити цей Exception.

Якщо блок catch знайдений, то він виконується, і після його завершення виконається блок finally.

Якщо потрібний блок catch не знайдений, то програма аварійно завершує своє виконання.

#### **Demo**

Покажу це все на практиці.

... 

Пишу код, вилітає помилка

Пишу трай, кетч, ловлю помилку і розказую про властивості об'єкту помилки

Базовим для всіх типів еxception-ів є тип Exception. Цей тип визначає ряд властивостей, за допомогою яких можна отримати інформацію про Exception.

InnerException: зберігає інформацію про Exception, через який виник цей Exception

Message: зберігає повідомлення про Exception, текст помилки

Source: зберігає ім'я об'єкта або збірки, яка викинула Exception

StackTrace: повертає колл стек викликів, які привели до Exception-а

TargetSite: повертає метод, в якому було відбувся Exception

#### **Exceptions Hierarchy**

У C# всі типи Exception-ів наслідуються від батьківського класу Exception, який додатково поділяється на дві гілки SystemException і ApplicationException.

SystemException - це базовий клас для всіх помилок CLR або програмного коду.

ApplicationException - це базовий клас для всіх Exception-ів, пов'язаних із додатком.

У випадку ApplicationException, є можливість створювати свої власні типи Exception-ів, успадкувавшись від класу Exception

SystemException містить всі відомі типи Exception, такі як DivideByZeroException або NullReferenceException і так далі.

#### **Demo Hierarchy**

...

#### **throw - Demo**

Після оператора throw вказується об'єкт Exception-a, в конструктор якого ми можемо передати повідомлення про помилку. Замість типу Exception ми можемо використовувати об'єкт будь-якого іншого типу Exception.

Подібним чином ми можемо генерувати Exception-и в будь-якому місці програми. Але існує також і інша форма використання оператора throw, коли після цього оператора нічого не вказується.

У подібному вигляді оператор throw може використовуватися тільки в блоці catch.

Різниця між ними у тому, що throw без нічого зберігає початковий stack trace, у той час як throw ех скидує stack trace до методу у якому зараз відбувається обробка Exception-у

----------------------------------

<Level id="clean-code-principles" number="4" name="Принципи чистого коду" difficulty="Такоє." objectives="Не придумано ще." labels={{ level: "Розділ", backToTop: "нагору", difficulty: "Складність:", objectives: "Мета:" }} />

<ul>
  <li class="details">
    <input type="checkbox" id="accordion-2-1" />
    <label class="summary" for="accordion-2-1">
      <h5><strong>Coding Standards and Naming Conventions</strong></h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>`Кодінг Стандарти` та `Неймінг конвеншини`. Дуже важлива бо це набір найкращих практик по тому, як огранізувати свій код, щоб він відповідав загальноприйнятим стандартам мови `С#`, яких дотримуються більшість `.Net` розробників. Це `ессеншл` для того, щоб інші девелопери могли легко та швидко зрозуміти що відбувається у вашому коді та використати його. Ці конвеншини є абсолютно у всіх мовах програмування, не тільки в `С#`. І це вважається хорошою практикою завжди дотримуватись їх при написанні коду на тій чи іншій мові. Розповідати про кожен конвеншн немає сенсу, так як це займе багато часу і освоїти це можна просто прочитавши кілька абзаців `Readme` з прикладами коду. Тому за посиланням на слайді ви зможете знайти список більшості `coding-standart`-ів мови `С#`.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-2-2" />
    <label class="summary" for="accordion-2-2">
      <h5 style="display: flex; align-items: center;">
        <span style="margin-right: 0.25em;">DRY</span>
        <small style="font-size: 0.5em; text-transform: uppercase;">
          <span style="text-decoration: line-through; opacity: 0.75; margin-right: 0.25em;">Don't Repeat</span>
          <span style="text-decoration: line-through; opacity: 0.75; margin-right: 0.25em;">Don't Repeat</span>
          <span style="text-decoration: line-through; opacity: 0.75; margin-right: 0.25em;">Don't Repeat</span>
          <span style="text-decoration: line-through; opacity: 0.75; margin-right: 0.25em;">Don't Repeat</span>
          Don't Repeat Yourself
        </small>
      </h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Це основний принцип розробки ПЗ, спрямований на зменшення повторюваності коду та логіки інформації. У випадках коли ми вже порушили принцип DRY і нам треба швидко щось порефакторити або змінити частину бізнес логіки, нам доведеться її змінити її усюди де ми продублювали імплементацію методу чи навіть усього класу бо не знали як розшарити його між збірками, або просто було ліньки. Це веде до надзвичайно великих проблем на реальному проекті, коли уже написано кілька сотень тисяч рядків коду і у тебе Студія вже не витримує, а ти по імені методу намагаєшся знайти цей нещасний кусок коду, щоб поміняти у цьому 1 цифру. Так не робиться :) Щоб досягнути DRY у вашому коді - діліть ваш код на маленькі кусочки, бачите що частина логіки повторюється - одразу виносьте, компонуйте функції. Чому потрібен DRY? Чим менше коду тим краще. Його легше підтримувати, менше часу йде на те щоб у ньому розібратися і також зменшується кількість багів.</p>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-2-3" />
    <label class="summary" for="accordion-2-3">
      <h5 style="display: flex; align-items: center;">
        <span style="margin-right: 0;"><strong>KISS<sup>💋</sup></strong></span>
        <small style="font-size: 0.5em; text-transform: uppercase;">
          Keep It Simple Stupid
        </small>
      </h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      <p>Цей принцип говорить сам за себе. Чим код простіший і чистіший тим його легше зрозуміти інший розробникам і навіть тобі через тиждень. За ним кожен метод повинен вирішувати лише одну маленьку проблему, а не покривати багато юз кейсів. Якщо у методі багато умов, розбийте їх на менші методи. Це буде легше читати, підтримувати і допоможе знайти помилки набагато швидше. Щоб показати KISS, найчастіше приводять приклад із визначенням дня тижня.</p>
      <div class="columns">
        <div class="column col-6">
          <h6><strong>Simple</strong></h6>
<div>

```csharp
string weekday(int day) {
    switch (day) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        case 4:
            return "Thursday";
        case 5:
            return "Friday";
        case 6:
            return "Saturday";
        case 7:
            return "Sunday";
        default:
            throw new Exception("Day must be in range 1 to 7");
    }
}
```

</div>
        </div>
        <div class="column col-6">
          <h6><strong>Stupid</strong></h6>
<div>

```csharp
string weekday(int day) {
    if ((day < 1) || (day > 7))
    {
        throw new Exception("Day must be in range 1 to 7");
    }
    
    string[] days = {
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday"
    };

    return days[day - 1];
}
```

</div>
        </div>
      </div>
      <div class="bubble small subtle">
        На слайді показано два методи для вирішення цієї задачі. Перше рішення просте як двері - простий свіч з дефолтним кейсом, якщо день не знайдено. Другий метод теж працює, але для того щоб його зрозуміти потрібно у кілька разів довше читати. Дивишся на індексатор ага, з масиву днів по індексу день дістаєш день. Так день мінус 1. А чо мінус 1. ааа бо масив починається з нуля і треба віднімати одиницю. Ясно, ну seems legin можна юзати. Такий код має причини на існування, але це нікому не потрібно 1 думаю 99% програмістів вибрали б перший варіант. Щоб досягнути KISS - просто старайтесь писати простий код. Якщо бачити важку ділянку коду, подумайте як простіше можна вирішити цю проблему і відрефакторіть вже нарешті ваш метод на 200 рядків! Дотримання KISS має очевидні бенефіти:
        <ul>
          <li>Перш за все це те що ви та ваші колеги розумієте що робить цей код - він декларативний та розбитий на невеликі частинки</li>
          <li>По друге через те що він простий його легко рефакторити та шукати помилки</li>
          <li>Ну і по 3-тє,якщо він простий як двері, його зачасту не потрібно дебажити - це і так зрозуміло, де потенційно проблема.</li>
        </ul>
      </div>
    </div>
  </li>
  <li class="details">
    <input type="checkbox" id="accordion-2-4" />
    <label class="summary" for="accordion-2-4">
      <h5 style="display: flex; align-items: center;">
        <span style="font-weight: 900; margin-right: 0.25em;">SOLID</span>
        <small style="font-size: 0.5em; text-transform: uppercase;">
          Single responsibility, Open–closed, Liskov substitution, Interface segregation, Dependency inversion
        </small>
      </h5>
    </label>
    <div class="details-body" style="margin-bottom: 0.5em;">
      SOLID — це 5 принципів об'єктно-орієнтованого програмування, які описують архітектуру програмного забезпечення. А якщо простіше, то це правила, дотримуючись який, ви будете писати код, який буде легко зрозуміти, змінити чи замінити та використати повторно.
      <ul>
        <li class="details">
          <input type="checkbox" id="accordion-2-4-1" />
          <label class="summary" for="accordion-2-4-1">
            <strong>Single responsibility</strong>
          </label>
          <div class="details-body">
            <p>Принцип єдиної відповідальності. Він означає, що кожен клас чи структура повинна відповідати лише за 1 ціль. Всі члени класу мають бути зв'язані єдиною метою і працювати разом щоб її досягти. Принцип єдиної відповідальності дає нам спосіб щоб для визначення класів ще на етапі проектування програми. Хорошого розподілу обов'язків можна досягти лише тоді коли в нас є повна картина того,як має працювати програма і ми знаємо точно хто й за що має відповідати.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
  <div>

```csharp
class Task
{
    public string Title { get; set; }
    public string Description { get; set; }

    // Adds task in Database
    public bool Add(Task tast)
    {
        // Internal realization(Insert into DB)
    }

    // Estimate Task's duration
    public void EstimateTaskDuration(Task tast)
    {
        // Calculation Task's difficulty, estimating
    }
}
```

  </div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```csharp
class Task
{
  public string Title { get; set; }
  public string Description { get; set; }

  // Adds task in Database
  public bool Add(Task tast)
  {
      // Internal realization(Insert into DB)
  }
}

class TaskEstimator
{
    // Estimate Task's duration
    public void EstimateTaskDuration(Task tast)
    {
        // Calculation Task's difficulty, estimating
    }
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">
              На прикладі класу Task, можна показати, що він не відповідає Single Responsibility Principle, так як він відповідає і за збереження Задачі в Базу Данних а також виконує бізнес логіку по обрахуванню та визначенню часу потрібного на вирішення Задачі. Клас Task не має нести відповідальність за обрахунок часу на її виконання, бо якщо через деякий час, у замовника поміняються вимоги до виконання усіх задач, тому що скоро реліз, або програмістів на проекті стало менше. І нам потрібно буде поміняти клас Task, якому взагалі по барабану на те що у вас реліз, Task-у треба зробити і все. Згідно Single Responsibility Principle, один клас має взяти на себе відповідальність, тому ми маємо створити окремий клас для естімейту Завдань, на основі бізнес логіки, задачі та зовнішніх чинників.
            </div>
          </div>
        </li>
        <li class="details">
          <input type="checkbox" id="accordion-2-4-3" />
          <label class="summary" for="accordion-2-4-3">
            <strong>Open–closed</strong>
          </label>
          <div class="details-body">
            <p>Принцип відкритості-закритості. Головнa концепція даного принципу є те, що клас повинен бути відкритий для розширення, але закритий для модифікацій. Наш модуль повинен бути розроблений так, щоб нова функціональність додавалась тільки при створенні нових вимог. «Закритий для модифікацій» означає, що ми вже розробили клас, ми не повинні міняти його, тільки якщо не знайдемо помилки що виправити її. У мові C# для реалізації цього принципу ідеально підходить успадкування.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
<div>

```csharp
class Mockup
{
    public string ImageType { get; set; }

    public Image ConvertImage(Image img)
    {
        if (ImageType == "tiff")
        {
            // Convert Image to the tiff format
        } 
        
        if (TypeReport == "cdr")
        {
            // Convert Image to the cdr format
        }
    }
}
```

</div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```csharp
abstract class Mockup
{
    public virtual void ConvertImage(Image img)
    {
        // Base realization that common for each format
    }
}

class MockupTiff : Mockup
{
    public override Image ConvertImage(Image img)
    {
        // Convert Image to the tiff format
    }
}

class MockupCdr : Mockup
{
    public override Image ConvertImage(Image img)
    {
        // Convert Image to the cdr format
    }
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">Розглянемо приклад з мокапом. Проблема цього класу в тому, що коли замовник захоче подивитись на мокап який намалювали дизайнери, але у нього не відкриває картинки формату tiff чи cdr тоді треба буде вносити новий формат картинки наприклад png. І для цього ми будем змушені додати нову умову if, що противорічить Open Closed Principle. На другому прикладі показано як це можна вирішити. Є базовий абстрактний клас Mockup, який частково реалізує конвертацію картинки, а дочірні класи реалізують конвертацію картинки в певний формат. І якщо ми захочемо добавити ще 1 формат, нам просто тре буде створити ще 1 клас унаслідуватись від Mockup і реазілувати метод.</div>
          </div>
        </li>
        <li class="details">
          <input type="checkbox" id="accordion-2-4-2" />
          <label class="summary" for="accordion-2-4-2">
            <strong>Liskov substitution</strong>
          </label>
          <div class="details-body">
            <p>За принципом пiдстановки Лiсков ми повинні мати можливість використовувати будь-який похідних клас замість батьківського і використовувати його так само, не вносячи зміни. Дочірній клас не має порушувати визначення типу батькіського класу та його поведінку.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
<div>

```csharp
abstract class Developer
{
    public virtual string CodeWebApp()
    {
        return "Coding Front-End Web App";
    }
    public virtual string CodeServer()
    {
        return "Coding Back-End Server";
    }
}
class JavaScriptDeveloper: Developer
{
    public override string CodeWebApp()
    {
        return "Coding Front-End with Angular";
    }
    public override string CodeServer()
    {
        return "Coding Back-End with Node.js";
    }
}
class CSharpDeveloper: Developer
{
    // C# Developer can't  create Front-End App
    public override string CodeWebApp()
    {
        throw new NotImplementedException(); 
    }
    public override string CodeServer()
    {
        return "Coding Back-End with ASP.Net";
    }
}
```

</div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```
interface IFrontend
{
    string CodeWebApp();
}

interface IBackend
{
    string CodeServer();
}

class JavaScriptDeveloper: IFrontend, IBackend
{
    public string CodeWebApp()
    {
        return "Coding Front-End with Angular";
    }
    public string CodeServer()
    {
        return "Coding Back-End with Node.js";
    }
}

class CSharpDeveloper: IBackend
{
    public string CodeServer()
    {
        return "Coding Back-End with ASP.Net";
    }
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">Давайте подивимося приклад з Розробниками. Developer є батьківський класом для JavaScript i C# Developer-ів. Як бачимо у нас клас Developer може створювати бекенд і фронтенд додатки. Здавалося б усе добре. JavaScript Developer успішно реалізовує 2 методи. А от з  C# Developer не все так просто, він може написати сервер на ASP.Net-і, але створити класного фронтенду. І якщо ми захочемо це зробити, то у нас вилетить Ексепшн. Для того щоб вирішити цю проблему нам потрібно розділити функціонал Developer-а на 2 частини: IFrontend та IBackend і реалізувати ці інтерфейси де ми маємо змогу. JavaScript Developer у нас реалізовує і Frontend і Backend, а C# Developer: тільки Backend.</div>
          </div>
        </li>
        <li class="details">
          <input type="checkbox" id="accordion-2-4-4" />
          <label class="summary" for="accordion-2-4-4">
            <strong>Interface segregation</strong>
          </label>
          <div class="details-body">
            <p>Принцип розділення інтерфейсів говорить, що клієнти не повинні примусово імплементовувати інтерфейси, які вони не використовують.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
<div>

```csharp
interface IDeveloper
{
    string CodeDesktop();
    string CodeServer();
}
```

</div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```csharp
interface IDesktop
{
    string CodeDesktop();
}

interface IBackend
{
    string CodeServer();
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">Давайте припустимо, що у нас є Інтерфейс IDeveloper, який тепер вміє написати сервер і десктоп додаток. Як і до дого у нас є JavaScript та C# Developer-и які успішно можуть це зробити. На JavaScript-і писався би під Електрон, а на C# WPF додаток. Все класно, всі задоволені. Але не всьо так просто. Шеф сказав, що ті додатки на Електрон-і в нього лагають і взагалі дорого платити цим JavaScript-розробникам. Урізаєм проекти під десктоп на JavaScript-і, пишем тіки на WPF. Але виходить ми ломаємо принцип Interface Segregation, бо JavaScript розробники все ще пишуть декстоп проекти. І рішенням цієї проблеми буде знову ж таки розділення інтерфейсу на кілька. На IDesktop та на IBackend. Це похоже до минулого прикладу, але тут ми вирішуєм іншу поблему - не даємо класу робити більше ніж потрібно.</div>
          </div>
        </li>
        <li class="details">
          <input type="checkbox" id="accordion-2-4-5" />
          <label class="summary" for="accordion-2-4-5">
            <strong>Dependency inversion</strong>
          </label>
          <div class="details-body">
            <p>І тепер останній і мабуть найважчий для розуміння принцип - інверсії залежностей. Цей принцип гласить, що:</p>
            <ol>
              <li>По-перше, класи високого рівня не повинні залежати від низькорівневих класів, при цьому обидва мають залежати від абстракцій.</li>
              <li>По-друге, абстракції не повинні залежати від деталей, але деталі мають залежати від абстракцій.</li>
            </ol>
            <p>Що це значить? А це значить, що класи високого рівня реалізують бізнес-правила або логіку в системі. Низькорівневі класи займаються більш детальними операціями, як от роботою з Базою Даних, передачею повідомлень в операційну систему і так далі. Щоб досягти інверсії залежностей ми повинні тримати ці високорівневі і низькорівневі класи настільки слабо зв'язними, наскільки можливо. Для цього нам потрібно зробити їх залежними від абстракцій, а не один від одного.</p>
            <div class="columns">
              <div class="column col-6">
                <h6><strong>Не SOLID 😢</strong></h6>
<div>

```csharp
class Email
{
    public void Send()
    {
        // Code to send email-letter
    }
}

class Notification
{
    private Email email;
    public Notification()
    {
        email = new Email();
    }

    public void EmailDistribution()
    {
        email.Send();
    }
}
```

</div>
              </div>
              <div class="column col-6">
                <h6><strong>SOLID 😎</strong></h6>
<div>

```csharp
interface IMessenger
{
    void Send();
}

class Email : IMessenger
{
    public void Send()
    { /* Code to send email-letter */ }
}

class SMS : IMessenger
{
    public void Send()
    { /* Code to send SMS */ }
}

class Notification
{
    public IMessenger Messenger { get; set; };
    public Notification(IMessenger mess)
    {
        Messenger = mess;
    }

    public void Notify()
    {
        Messenger.Send();
    }
}

static void Main(string[] args)
{
    var notification = new Notification(new Email());
    notification.Notify(); // Sent email
    notification.Messenger = new SMS(); // Change the provider
    notification.Notify(); // Sent SMS
}
```

</div>
              </div>
            </div>
            <div class="bubble small subtle">Давайте розглянемо цей принцип на прикладі розсилки повідомлень. На першому сніппеті коду клас Notification повністю залежить від класу Email, тому що він відправляє тільки один тип повідомлень. Якщо ми захочемо відправляти повідомлення якимсь іншим способом? Тоді нам треба буде перелопачувати всю систему повідомлень. Це є признаком того, що система є тісно св'язною. Для того щоб зробити її слабо зв'язною, нам потрібно абстрагуватися від провайдера відправки повідомлень, а саме - Емейл-у.  Для цього ми створюємо interface IMessenger з методом Send і реалізуємо його у двох класах - Email і SMS. Клас Notification ми дизайнимо так, щоб відв'язатись від конкретної реалізації розсилки повідомлень. В цьому випадку ми можемо використати принцип dependency injection, прокинувши об'єкт Messenger-а через конструктор. І в залежності від того, екземпляр якого класу це буде, такі повідомлення ми і будемо відсилати. Ось на прикладі ми створюємо Notification з Email Messenger-ом, посилаємо емейл. Далі ми захотіли поміняти провайдера, і присвоюємо властивості Messenger - SMS-провайдер. Наступний виклик методу Notify уже надішле SMS-ку.</div>
          </div>
        </li>
      </ul>
      <p>Отож, підсумовуючи можна сказати, що кожеш принцип SOLID пропонує нам шлях до написання логічного, надійного та зрозумілого коду а мова С# дає змогу дотримуватись цих принципипів та писати великі програми та легко розширювати їх.</p>
    </div>
  </li>
</ul>

export const metadata = {
  author: "Rostyslav Diakiv",
  title: ".NET ecosystem and C# best practices",
  description: "",
  keywords: ["hola", "guapa"]
}

export default Lecture;